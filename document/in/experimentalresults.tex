In this section, each part is described in terms of implementation. The firstimportant part would be the objective function.\begin{lstlisting}for (u_int i=0; i<n; i++) //All nodes in tale{    for (u_int j=0; j<n; j++) //All nodes in head    {    	for (u_int k=0; k<m; k++) //All tours        {            //Choice of using connection between i and j            x[i, j, k] = IloIntVar(env, 0, max, xname.str().c_str());                        //Sum over the cost of all connections            totalCosts += (x[i,j,k] * Distance(i,j));        }    }}...model.add(x);model.add(IloMinimize(env, totalCosts));     \end{lstlisting}As it is shown in the code above, there is a decision variable called\texttt{ max } used to eliminate all unwilling cases from possible selectedpossibilities. For instance this variable is \texttt{ 1 } for a connection froma node $D$ to a node $S$ or vice versa but \texttt{ 0 } for a connection betweentwo nodes with the same type since we don't want to have any direct connectionfrom a $S$ node to another $S$ node or any $D$ node to another $D$ node.Moving, we get to the constraints. In order to keep this report short enough,only one samples of how the constraints are implemented, is presented. As an instance, we know that sum of incoming connections foreach node should be exactly equal to the sum of outgoing connections from thatnode. This constraint is implemented as following:\begin{lstlisting}for(u_int j=0; j<n; ++j) //all nodes{    for(u_int k=0; k<m; ++k) //in all tours     {        IloExpr incomingConnections(env);        for(u_int i=0; i<n; ++i) //sum of incomming connections        {            incomingConnections += x[i,j,k];        }        IloExpr outgoingConnections(env);        for(u_int l=0; l<n; ++l) //sum of outgoing connections        {            outgoingConnections += x[j,l,k];        }        model.add(incomingConnections == outgoingConnections); //equal    }}\end{lstlisting}