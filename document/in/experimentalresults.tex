In this section, each part is described in terms of implementation. The firstimportant part would be the objective function.\begin{lstlisting}for (u_int i=0; i<n; i++) //All nodes in tale{    for (u_int j=0; j<n; j++) //All nodes in head    {    	for (u_int k=0; k<m; k++) //All tours        {            //Choice of using connection between i and j            x[i, j, k] = IloIntVar(env, 0, max, xname.str().c_str());                        //Sum over the cost of all connections            totalCosts += (x[i,j,k] * Distance(i,j));        }    }}...model.add(x);model.add(IloMinimize(env, totalCosts));     \end{lstlisting}As it is shown in the code above, there is a decision variable called\texttt{ max } used to eliminate all unwilling cases from possible selectedpossibilities. For instance this variable is \texttt{ 1 } for a connection froma node $D$ to a node $S$ or vice versa but \texttt{ 0 } for a connection betweentwo nodes with the same type since we don't want to have any direct connectionfrom a $S$ node to another $S$ node or any $D$ node to another $D$ node.Moving, we get to the constraints. In order to keep this report short enough,only one samples of how the constraints are implemented, is presented and therest lie in the code which is enclosed and fully documented.As an instance, we know that sum of incoming connections for each node should be exactly equal to the sum of outgoing connections from thatnode. This constraint is implemented as below:\begin{lstlisting}for(u_int j=0; j<n; ++j) //over all nodes{    for(u_int k=0; k<m; ++k) //in all tours     {        IloExpr incomingConnections(env);        for(u_int i=0; i<n; ++i) //sum of incomming connections        {            incomingConnections += x[i,j,k];        }        IloExpr outgoingConnections(env);        for(u_int l=0; l<n; ++l) //sum of outgoing connections        {            outgoingConnections += x[j,l,k];        }        model.add(incomingConnections == outgoingConnections); //equal    }}\end{lstlisting}The other important part of the implementation is eliminating subtours fromresults. Such subtours are not connected to the node \texttt{depot}. Thus it isdecided to emit the initial flow from the node \texttt{depot} to all tourssimultaneously and evaluate the inflow of the  \texttt{depot} at the end. On theother hand, by characteristics of the problem we know that only one of the nodes$D$ or $S$ alone cannot appear in a path and they come consecutively. Thus inthe implementation only half of the nodes in a tour which are $D$ nodes areconsidered as consumers of flow and therefore $\frac{l_k}{2}-1$, $l_k$ denotingthe number of participant nodes in each tour, is the flow amount emitted fromthe \texttt{depot} for that tour.Finally:\begin{center}$\sum_{k=0}^{m}{\frac{n_k}{2}-1} = \#D - 1$
\end{center}\subsection{Single commodity flows}So for {\it single commodity flows} we have counted all connected $D$ nodes tothe \texttt{depot} over all tours and it must be exactly the number of $D$ nodes in whole system.\begin{lstlisting}IloExpr sumDepot(env);for(u_int k=0; k<m; ++k){    for(u_int j=1; j<n; ++j) //n-1 going out from the depot    {        sumDepot += flow[0,j,k];    }    for(u_int j=1; j<n; j++) //outgoing flow matches incoming flow    {        IloIntVar any(env, 0, 1); //decision variable for D nodes        IloExpr sumIncoming(env);        .        .        .        if(instance.isDemandNode(j)) //only connected D nodes consume        {            //any:1 if node is in the route from depot otherwise 0            model.add((sumIncoming - sumOutgoing) == any);        }        else        {            model.add((sumIncoming - sumOutgoing) == 0);        }    }    for(u_int i=0; i<n; i++) //flow at most n-1 or 0    {        for(u_int j=0; j<n; j++)        {            if(i==j) continue;            model.add(flow[i,j,k] >= 0);            model.add(flow[i,j,k] <= (x[i,j,k] * ((int) n-1)));        }    }}model.add(sumDepot == instance.nDemandNodes()); //decision for inflow of depot\end{lstlisting}\subsection{Multi commodity flows}Multi commodity flows is considerable similar to single commodity flows. Theonly difference is that this time, \texttt{ depot } sends out only $p$ flows outbut $n$ times, in our case $\#D$ times, and expects $p-1$ back. Consequently,wrapping the code used for single commodity flows in a loop which iterates $\#D$times and deciding over \texttt{(sumDepotOut - sumDepotIn) == 1} results inelimination of subtours using multi commodity flows.\subsection{Miller-Tucker-Zemlin subtour elimination constraints}