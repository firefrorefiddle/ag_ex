In this section, each part is described in terms of implementation. All codesare in {\it C++} language using CPLEX Solver.The first important part would be the objective function.As it is shown in the code above, there is a decision variable called\texttt{ max } used to eliminate all unwilling cases from possible selectedpossibilities. For instance this variable is \texttt{ 1 } for a connection froma node $D$ to a node $S$ or vice versa but \texttt{ 0 } for a connection betweentwo nodes with the same type since we don't want to have any direct connectionfrom a $S$ node to another $S$ node or any $D$ node to another $D$ node.Moving, we get to the constraints. In order to keep this report short enough,only one samples of how the constraints are implemented, is presented and therest lie in the code which is enclosed and fully documented and can be found atits GitHub repository\footnote{\url{https://github.com/firefrorefiddle/ag_ex}}.As an instance, we know that sum of incoming connections for each node shouldbe exactly equal to the sum of outgoing connections from that node. Thisconstraint is implemented as shown in Appendix\ref{app:app01}.The other important part of the implementation is eliminating subtours fromresults. Such subtours are not connected to the node \texttt{depot}. Thus it isdecided to emit the initial flow from the node \texttt{depot} to all tourssimultaneously and evaluate the inflow of the  \texttt{depot} at the end. On theother hand, by characteristics of the problem we know that only one of the nodes$D$ or $S$ alone cannot appear in a path and they come consecutively. Thus inthe implementation only half of the nodes in a tour which are $D$ nodes areconsidered as consumers of flow and therefore $\frac{l_k}{2}-1$, $l_k$ denotingthe number of participant nodes in each tour, is the flow amount emitted fromthe \texttt{depot} for that tour.Finally:\begin{center}$\sum_{k=0}^{m}{\frac{l_k}{2}-1} = |D| - 1$
\end{center}\subsection{Single commodity flows}So for {\it single commodity flows} we have counted all connected $D$ nodes tothe \texttt{depot} over all tours and it must be exactly $|D|$ nodes in wholesystem.A simplified version of the implementation of this part is demonstrated inAppendix\ref{app:app02}.\subsection{Multi commodity flows}Multi commodity flows is considerable similar to single commodity flows. Theonly difference is that this time, \texttt{ depot } sends out only $p$ flows outbut $n$ times, in our case $\#D$ times, and expects $p-1$ back. Consequently,wrapping the code used for single commodity flows in a loop which iterates $\#D$times and deciding over \texttt{(sumDepotOut - sumDepotIn) == 1} results inelimination of subtours using multi commodity flows.\subsection{Miller-Tucker-Zemlin subtour elimination constraints}